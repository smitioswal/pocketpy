[[{"l":"Welcome to pocketpy","p":["pkpy is a lightweight(~ 14K LOC) Python interpreter for game scripting, built on C++ 17 with STL.","It aims to be an alternative to lua for game scripting, with elegant syntax, powerful features and competitive performance. pkpy is extremely easy to embed via a single header file pocketpy.h, without external dependencies.","Caution: pocketpy should not be your first C++ project. Please learn C++ programming, compiling, linking, and debugging before working with pocketpy. There are many resources for this on the net."]},{"l":"What it looks like"},{"l":"Supported Platforms","p":["pkpy should work on any platform with a C++ 17 compiler. These platforms are officially tested.","Windows 64-bit","Linux 64-bit / 32-bit","macOS 64-bit","Android 64-bit / 32-bit","iOS 64-bit","Emscripten 32-bit","Raspberry Pi 64-bit"]},{"l":"Sponsor me","p":["You can sponsor me via Github Sponsors."]}],[{"l":"Cheat sheet"},{"l":"Basics","p":["Setup pocketpy","Create a python virtual machine","Dispose a python virtual machine","Execute a source string","Evaluate a source string","Compile a source string into a code object","Execute a compiled code object"]},{"l":"Interop with native types","p":["Create primitive objects","Create a tuple object","Create a list object","Create a dict object","Get native types from python objects","Get native types without type checking"]},{"l":"Access python types","p":["Access built-in python types","Access extended python types","Check if an object is a python type","Get the type of a python object","Convert a type object into a type index"]},{"l":"Access attributes","p":["Check an object supports attribute access","Get and set attributes"]},{"l":"Call python functions","p":["Call a function","Call a method","Cache the name of a function or method to avoid string-based lookup"]},{"l":"Special operations","p":["Compare two python objects","Convert a python object to string","Get the string representation of a python object","Get the JSON representation of a python object","Get the hash value of a python object","Get the iterator of a python object","Get the next item of an iterator","Convert a python iterable to a list"]},{"l":"Bindings","p":["Bind a native function","Bind a property"]},{"l":"Modules","p":["Create a source module","Create a native module"]}],[{"l":"Installation","p":["You have two options to integrate pkpy into your project."]},{"l":"Use the single header file","p":["Download the pocketpy.h on our GitHub Release page. And #include it in your project. It is recommended to use the latest dev version."]},{"l":"Use CMake","p":["Clone the whole repository as a submodule in your project, You need Python 3 installed on your system because CMakeLists.txt requires it to generate some files.","In your CMakelists.txt, add the following lines:","These variables can be set to control the build process:","PK_BUILD_STATIC_LIB- Build the static library","PK_BUILD_SHARED_LIB- Build the shared library","PK_USE_BOX2D- Build with Box2D module","See CMakeLists.txt for details."]},{"l":"Compile flags","p":["To compile it with your project, these flags must be set:","--std=c++17 flag must be set","Exception must be enabled","For emscripten, you must enable exceptions to make pocketpy work properly. See https://emscripten.org/docs/porting/exceptions.html."]},{"l":"Example"},{"l":"Overview","p":["pkpy's C++ interfaces are organized in an object-oriented way. All classes are located in pkpy namespace.","The most important class is the VM class. A VM instance is a python virtual machine which holds all necessary runtime states, including callstack, modules, variables, etc.","A process can have multiple VM instances. Each VM instance is independent from each other.","Always use C++ new operator to create a VM instance. DO NOT declare it on the stack. It may cause stack overflow.","The constructor can take 1 extra parameters."]},{"i":"vmbool-enable_ostrue","l":"VM(bool enable_os=true)","p":["enable_os, whether to enable OS-related features or not. This setting controls the availability of priviledged modules such os io and os as well as builtin function open. It is designed for sandboxing.","When you are done with the VM instance, use delete operator to dispose it."]},{"l":"Hook standard buffer","p":["By default, pkpy outputs all messages and errors to stdout and stderr. You can redirect them to your own buffer by setting vm-_stdout and vm-_stderr.","These two fields are C function pointers PrintFunc with the following signature:"]}],[{"l":"Execute Python code"},{"l":"Simple execution","p":["Once you have a VM instance, you can execute python code by calling exec method."]},{"i":"pyobject-execstr-source-str-filename-compilemode-mode-pyobject-_modulenullptr","l":"PyObject* exec(Str source, Str filename, CompileMode mode, PyObject* _module=nullptr)","p":["source, the python source code to be executed","filename, the filename of the source code. This is used for error reporting","mode, the compile mode. See below for details","module, the module where the code will be executed. If nullptr, the code will be executed in the __main__ module","exec handles possible exceptions and returns a PyObject*. If the execution is not successful, e.g. a syntax error or a runtime exception, the return value will be nullptr.","There are also overloaded versions of exec and eval, which is useful for simple execution:","PyObject* exec(Str source)","PyObject* eval(Str source)"]},{"l":"Compile mode","p":["The mode parameter controls how the source code is compiled. There are 5 possible values:","EXEC_MODE, this is the default mode. Just do normal execution.","EVAL_MODE, this mode is used for evaluating a single expression. The source should be a single expression. It cannot contain any statements.","REPL_MODE, this mode is used for REPL. It is similar to EXEC_MODE, but generates PRINT_EXPR opcode when necessary.","CELL_MODE, this mode is designed for Jupyter like execution. It is similar to EXEC_MODE, but generates PRINT_EXPR opcode when necessary.","JSON_MODE, this mode is used for JSON parsing. It is similar to EVAL_MODE, but uses a lexing rule designed for JSON."]},{"l":"Fine-grained execution","p":["In some cases, you may want to execute python code in a more fine-grained way. These two methods are provided for this purpose:","CodeObject_ compile(Str source, Str filename, CompileMode mode, bool unknown_global_scope)","PyObject* _exec(CodeObject_ co, PyObject* _module)","compile compiles the source code into a CodeObject_ instance. Leave unknown_global_scope to false if you don't know what it means.","_exec executes the CodeObject_ instance.","_exec does not handle exceptions, you need to use try..catch manually."]}],[{"l":"Interop with PyObject","p":["In pkpy, any python object is represented by a PyObject*."]},{"i":"create-pyobject-from-c-type","l":"Create PyObject* from C type","p":["A set of overloaded function PyObject* py_var(VM* vm, ...) were implemented to create a PyObject* from a supported C type.","Assume we have a VM* vm instance. You can create a python int object from a C i64 type:","Each python type has a corresponding C type, for example, int in python is i64 in C. python's list corresponds to List, str corresponds to Str, etc. For strings, we have defined a set of overloaded version including const char*, std::string, std::string_view, Str, etc.","A more complex example is to create a python list. In the following code, we create a list equals to [0, 1, 2, 3].","Please note that std::move is used here to avoid unnecessary copy. Most types have both a rvalue and a lvalue version of py_var function."]},{"i":"access-internal-c-type-of-pyobject","l":"Access internal C type of PyObject*","p":["A set of template function T py_castT(VM* vm, PyObject* obj) were implemented.","The py_cast function will check the type of obj before casting. If the type is not matched, a TypeError will be thrown.","However, this type check has a cost. If you are sure about the type of obj, you can use the underscore version _py_cast to skip the type check.","For complex objects like list, we can use reference cast to avoid unnecessary copy."]},{"i":"check-type-of-pyobject","l":"Check type of PyObject*","p":["Each PyObject* has a Type type field to indicate its type. Type is just an integer which is the global index in vm-_all_types.","VM class has a set of predefined Type constants for quick access. They are prefixed by tp_. For example, tp_object(object), tp_int(int), tp_str(str), tp_list(list), etc.","Types are divided into tagged type and non-tagged type.","int(small) and float are tagged type.","Other types are non-tagged type.","To determine whether a PyObject* is of a specific type, you can use the following functions:","bool is_type(PyObject* obj, Type type)","bool is_int(PyObject* obj)","bool is_float(PyObject* obj)","bool is_tagged(PyObject* obj)","bool is_non_tagged_type(PyObject* obj, Type type)","Simply put, is_type is the most general function and can check any types. Other variants are designed for specific types and are faster.","You can also use check_ prefix functions assert the type of a PyObject*, which will throw TypeError on failure.","void check_type(PyObject* obj, Type type)","void check_non_tagged_type(PyObject* obj, Type type)"]}],[{"l":"Access attributes"},{"l":"Direct access","p":["Some python objects have an instance dict, a.k.a, __dict__ in cpython. You can use obj-attr() to manipulate the instance dict of an object.","However, you cannot call attr on an object which does not have an instance dict. For example, the int object.","To determine whether an object has instance dict or not, you can use this snippet."]},{"l":"General access","p":["As you can see, direct access does not take care of derived attributes or methods. In most cases, what you need is getattr and setattr. These two methods handle all possible cases."]},{"i":"pyobject-getattrpyobject-obj-strname-name-bool-throw_errtrue","l":"PyObject* getattr(PyObject* obj, StrName name, bool throw_err=true)","p":["This method is equivalent to getattr in python. If the attribute is not found, it will return nullptr or throw an AttributeError depending on the value of throw_err."]},{"i":"void-setattrpyobject-strname-pyobject","l":"void setattr(PyObject*, StrName, PyObject*)","p":["This method is equivalent to setattr in python. It raises TypeError if the object does not support attribute assignment."]}],[{"l":"Call Python function","p":["pkpy uses a variant of the Vectorcall protocol (PEP 590).","You can use call to invoke any python callable object, including functions, methods, classes, etc. For methods, call_method can be used.","PyObject* call(PyObject* obj, ...)","PyObject* call_method(PyObject* obj, StrName name, ...)"]},{"l":"Exmaple","p":["Let's create a dict object and set a key-value pair, which equals to the following python snippet.","First, create an empty dict object,","And set a key-value pair,","And get the value,"]}],[{"l":"Create modules","p":["Modules are stored in vm-_modules and vm-_lazy_modules. They are both dict-like objects."]},{"l":"Lazy modules","p":["A lazy module is a python source file. It is compiled and executed when it is imported. Use [] operator to add a lazy module."]},{"l":"Native modules","p":["A native module is a module written in c++ or mixed c++/python. Native modules are always compiled and executed when the VM is created.","To creata a native module, use vm-new_module(Str name)."]},{"l":"Module resolution order","p":["When you do import a module, the VM will try to find it in the following order:","Search vm-_modules, if found, return it.","Search vm-_lazy_modules, if found, compile and execute it, then return it.","Try vm-_import_handler."]},{"l":"Customized import handler","p":["You can use vm-_import_handler to provide a custom import handler for the 3rd step. if both enable_os and PK_ENABLE_OS are true, the default import_handler is as follows:"]},{"l":"Import module via cpp","p":["You can use vm-py_import to import a module. This is equivalent to import in python. Return the module object if success."]}],[{"l":"Use dynamic library","p":["This feature is optional. Set PK_USE_DYLIB to 1 to enable it.","You can import a native module from a dynamic library at runtime. This feature is supported on Windows, Linux, macOS, and Android."]},{"l":"Create a module as a dynamic library","p":["Implement a pkpy_module__init__ function and export it as a symbol. This is the entry point of the module. When users call __import__ function, the VM will call this function to initialize the module.","You can create one or more modules inside pkpy_module__init__ function, and return the name of the module you want users to import directly.","You should use C-APIs to interact with the VM in the dynamic library. This is to make sure the dynamic library is compatible with different compilers."]},{"l":"Load a dynamic library","p":["You can load a dynamic library with __import__ function with a path to the library."]}],[{"l":"Advanced config"},{"l":"Disable os-related features","p":["If you want to disable os-related features, you can do this before including pocketpy.h."]},{"l":"Working with multiple threads","p":["pkpy does not support multi-threading. But you can create multiple VM instances and run them in different threads. You can do the following to ensure thread safety for VM instances:"]},{"l":"Full config","p":["You can create a user_config.h in the same directory as pocketpy.h to override some default settings.","Copy src/config.h and rename it to user_config.h.","Define a macro PK_USER_CONFIG_H in user_config.h. This invalidates the default config.h and enables your user_config.h.","Edit user_config.h to override default settings."]}],[{"l":"Write bindings","p":["In order to use a C/C++ library in python, you need to write bindings for it."]},{"l":"Automatic bindings","p":["pkpy supports automatic binding generation only for C libraries. See pkpy-bindings for details.","It takes a C header file and generates a python module stub (*.pyi) and a C++ binding file (*.cpp)."]},{"l":"Manual bindings","p":["pkpy uses an universal signature to wrap a function pointer as a python function or method that can be called in python code, i.e NativeFuncC.","The first argument is the pointer of VM instance.","The second argument is an array-like object indicates the arguments list. You can use [] operator to get the element and call size() to get the length of the array.","The return value is a PyObject*, which should not be nullptr. If there is no return value, return vm-None."]},{"l":"Bind a function or method","p":["Use vm-bind to bind a function or method.","PyObject* bind(PyObject*, const char* sig, NativeFuncC)","PyObject* bind(PyObject*, const char* sig, const char* docstring, NativeFuncC)","Other documents are working in progress."]},{"l":"Bind a property","p":["a property is a python's property that attached to a type instance with a getter and an optional setter. It is a data descriptor. A property redirects attribute access to specific functions.","Use vm-bind_property() to bind a getter and an optional setter to a property."]},{"l":"Others","p":["You may see somewhere in the code that vm-bind_method or vm-bind_func is used. They are old style binding functions and are deprecated. You should use vm-bind instead.","For some magic methods, we provide specialized binding function. They do not take universal function pointer as argument. You need to provide the detailed Type object and the corresponding function pointer.","This specialized binding function has optimizations and result in better performance when calling from python code.","For example, vm-bind__add__ is preferred over vm-bind_method1(type, __add__, ...).","Add PY_CLASS macro into your struct and implement a static function _register. Inside the _register function, you can bind methods and properties to the class."]},{"l":"Example","p":["In this example, we will create a linalg module and implement a vec2 type with some methods. And make them available in python just like this."]},{"l":"Implement Vec2 struct in cpp"},{"l":"Create PyVec2 wrapper"},{"l":"Create linalg module"},{"l":"Further reading","p":["See linalg.h for the complete implementation."]}],[{"l":"Basic Features","p":["(1, 2, 'a')","[1, 2, 'a']","[i for i in range(5)]","{'a': 1, 'b': 2}","@cache","a, *b = [1, 2, 3]","a, b = 1, 2","a[1:2], a[:2], a[1:]","Check this Cheatsheet for a quick overview of the supported features.","class A(B):","Context Block","Decorator","def f(a:int, b:float=1)","def f(x,*args,y=1):","Dict","Dynamic Code","eval()/exec()","Example","Exception","F-String","f'value is {x}'","for/while/break/continue","Function","Generator","hasattr()/getattr()/setattr()","If Else","if..else..elif","Import","import/from..import","List","ListComp","Loop","Name","raise/try..catch","Reflection","Slice","Star Unpacking","Subclass","Supported","The following table shows the basic features of pkpy with respect to cpython. The features marked with YES are supported, and the features marked with NO are not supported.","Tuple","Type Annotation","Unpacking","with expr as id:","YES","yield i"]},{"l":"Supported magic methods"},{"l":"Unary operators","p":["__repr__","__str__","__hash__","__len__","__iter__","__next__","__json__","__neg__","__bool__(unused)"]},{"l":"Logical operators","p":["__eq__","__lt__","__le__","__gt__","__ge__","__contains__"]},{"l":"Binary operators","p":["__add__","__and__","__floordiv__","__invert__","__lshift__","__matmul__","__mod__","__mul__","__or__","__pow__","__radd__","__rmul__","__rshift__","__rsub__","__sub__","__truediv__","__xor__"]},{"l":"Indexer","p":["__getitem__","__setitem__","__delitem__"]},{"l":"Specials","p":["__new__","__init__","__call__","__divmod__","__enter__","__exit__","__name__","__all__"]}],[{"l":"Comparison with CPython","p":["cpython is the reference implementation of the Python programming language. It is written in C and is the most widely used implementation of Python."]},{"l":"The design goal","p":["pkpy aims to be an alternative to lua for game scripting, not cpython for general purpose programming.","For syntax and semantics, pkpy is designed to be as close to cpython as possible.","For ecosystem and others, pkpy is not compatible with cpython.","pkpy supports most of the syntax and semantics of python. For performance and simplicity, some features are not implemented, or behave differently. The easiest way to test a feature is to try it on your browser."]},{"l":"Unimplemented features","p":["__getattr__ and __setattr__.","Descriptor protocol __get__ and __set__. However, @property is implemented.","__slots__ in class definition.","Access the exception object in try..except.","else clause in try..except.","Inplace methods like __iadd__ and __imul__.","__del__ in class definition.","Multiple inheritance."]},{"l":"Different behaviors","p":["positional and keyword arguments are strictly evaluated.","When a generator is exhausted, StopIteration is returned instead of raised.","++i and --j is an increment/decrement statement, not an expression.","int does not derive from bool.","int is 64-bit. You can use long type explicitly for arbitrary sized integers.","__ne__ is not required. Define __eq__ is enough.","Raw string cannot have boundary quotes in it, even escaped. See #55.","In a starred unpacked assignment, e.g. a, b, *c = x, the starred variable can only be presented in the last position. a, *b, c = x is not supported.","A Tab is equivalent to 4 spaces. You can mix Tab and spaces in indentation, but it is not recommended.","%, , //, ^ and | for int behave the same as C, not python."]}],[{"l":"Arbitrary Sized Integers","p":["Unlike cpython, pkpy's int is of limited precision (64-bit).","For arbitrary sized integers, we provide a builtin long type, just like python2's long. long is implemented via pure python in _long.py.","This feature is still under development. Some operations are missing, and some operations are not optimized."]},{"l":"Create a long object","p":["You can use L suffix to create a long literal from a decimal literal. Also, you can use long() function to create a long object from a int object or a str object."]}],[{"l":"Goto Statement","p":["pkpy supports goto/label just like C. You are allowed to change the control flow unconditionally.","This feature is stable after v1.2.2."]},{"l":"Define a label"},{"l":"Goto a label"},{"l":"Example"}],[{"l":"Increment Statement","p":["pkpy provides ++i and --j statements to operate a simple named int variable.","++i is equivalent to i+=1, but much faster","--j is equivalent to j-=1, but much faster"]},{"l":"Example"}],[{"l":"Undefined Behaviour","p":["These are the undefined behaviours of pkpy. The behaviour of pkpy is undefined if you do the following things.","Delete a builtin object. For example, del int.__add__.","Call an unbound method with the wrong type of self. For example, int.__add__('1', 2).","Use goto statement to jump out of a context block.","Type T's __new__ returns an object that is not an instance of T.","Call __new__ with a type that is not a subclass of type.","__eq__, __lt__ or __contains__, etc.. returns a value that is not a boolean."]}],[{"l":"base64"},{"i":"base64b64encodeb-bytes---bytes","l":"base64.b64encode(b: bytes) - bytes","p":["Encode bytes-like object b using the standard Base64 alphabet."]},{"i":"base64b64decodeb-bytes---bytes","l":"base64.b64decode(b: bytes) - bytes","p":["Decode Base64 encoded bytes-like object b."]}],[{"l":"bisect"},{"i":"bisectbisect_lefta-x","l":"bisect.bisect_left(a, x)","p":["Return the index where to insert item x in list a, assuming a is sorted."]},{"i":"bisectbisect_righta-x","l":"bisect.bisect_right(a, x)","p":["Return the index where to insert item x in list a, assuming a is sorted."]},{"i":"bisectinsort_lefta-x","l":"bisect.insort_left(a, x)","p":["Insert item x in list a, and keep it sorted assuming a is sorted.","If x is already in a, insert it to the left of the leftmost x."]},{"i":"bisectinsort_righta-x","l":"bisect.insort_right(a, x)","p":["Insert item x in list a, and keep it sorted assuming a is sorted.","If x is already in a, insert it to the right of the rightmost x."]}],[{"l":"box2d","p":["This module is optional. Set PK_USE_BOX2D to 1 to enable it.","Box2D by Erin Catto, the world's best 2D physics engine now becomes a built-in module in pkpy v1.1.3 and later. All platforms are supported, including desktop, mobile and web."]},{"l":"Overview","p":["The box2d module in pkpy provides a high-level, also simplified, interface to Box2D engine, which is suitable for most use cases. There are two classes in box2d module: World and Body.","World is the world of Box2D, it is the container of all Body s. In most cases, you only need one World instance. World class provides methods to create, destroy and query Body s and also methods to step the simulation.","A Body instance is a physical entity in the world. A Body can only have one shape at a time. For example, a circle, a rectangle, a polygon, etc. You are allowed to change the shape of a Body at runtime. Body s can be static, dynamic or kinematic. A static Body is not affected by forces or collisions. A dynamic Body is fully simulated. A kinematic Body moves according to its velocity. Body class provides methods to set its properties, such as position, velocity, etc. It also provides methods to apply forces and impulses to it.","A box2d.Body in pkpy is an unified wrapper of Box2D's b2Body, b2Shape and b2Fixture. It hides the details of Box2D's API and provides a high-level interface."]},{"l":"APIs","p":["https://github.com/blueloveTH/pocketpy/blob/main/include/typings/box2d.pyi"]},{"l":"Example"}],[{"l":"c","p":["Interop with pointers and C structs.","https://github.com/blueloveTH/pocketpy/blob/main/include/typings/c.pyi"]}],[{"l":"collections"},{"i":"collectionscounteriterable","l":"collections.Counter(iterable)","p":["Return a dict containing the counts of each element in iterable."]},{"i":"collectionsdeque","l":"collections.deque","p":["A double-ended queue."]},{"i":"collectionsdefaultdict","l":"collections.defaultdict","p":["A dict wrapper that calls a factory function to supply missing values. It is not a subclass of dict."]}],[{"l":"colorsys","p":["The same as the standard library module colorsys in python 3.11.","https://github.com/python/cpython/blob/3.11/Lib/colorsys.py"]}],[{"l":"datetime"},{"i":"datetimenow","l":"datetime.now()","p":["Returns the current date and time as a datetime object."]},{"i":"datetoday","l":"date.today()","p":["Returns the current local date as a date object."]}],[{"l":"easing","p":["EaseInBack(x: float) - float","EaseInBounce(x: float) - float","EaseInCirc(x: float) - float","EaseInCubic(x: float) - float","EaseInElastic(x: float) - float","EaseInExpo(x: float) - float","EaseInOutBack(x: float) - float","EaseInOutBounce(x: float) - float","EaseInOutCirc(x: float) - float","EaseInOutCubic(x: float) - float","EaseInOutElastic(x: float) - float","EaseInOutExpo(x: float) - float","EaseInOutQuad(x: float) - float","EaseInOutQuart(x: float) - float","EaseInOutQuint(x: float) - float","EaseInOutSine(x: float) - float","EaseInQuad(x: float) - float","EaseInQuart(x: float) - float","EaseInQuint(x: float) - float","EaseInSine(x: float) - float","EaseLinear(x: float) - float","EaseOutBack(x: float) - float","EaseOutBounce(x: float) - float","EaseOutCirc(x: float) - float","EaseOutCubic(x: float) - float","EaseOutElastic(x: float) - float","EaseOutExpo(x: float) - float","EaseOutQuad(x: float) - float","EaseOutQuart(x: float) - float","EaseOutQuint(x: float) - float","EaseOutSine(x: float) - float","Python wrapper for easing functions."]}],[{"l":"gc"},{"i":"gccollect","l":"gc.collect()","p":["Invoke the garbage collector."]}],[{"l":"heapq"},{"i":"heapqheappushheap-item","l":"heapq.heappush(heap, item)","p":["Push the value item onto the heap, maintaining the heap invariant."]},{"i":"heapqheappopheap","l":"heapq.heappop(heap)","p":["Pop and return the smallest item from the heap, maintaining the heap invariant. If the heap is empty, IndexError is raised. To access the smallest item without popping it, use heap[0]."]},{"i":"heapqheapifyx","l":"heapq.heapify(x)","p":["Transform list x into a heap, in-place, in linear time."]},{"i":"heapqheappushpopheap-item","l":"heapq.heappushpop(heap, item)","p":["Push item on the heap, then pop and return the smallest item from the heap. The combined action runs more efficiently than heappush() followed by a separate heappop()."]},{"i":"heapqheapreplaceheap-item","l":"heapq.heapreplace(heap, item)","p":["Pop and return the smallest item from the heap, and also push the new item. The heap size doesn’t change. If the heap is empty, IndexError is raised."]}],[{"l":"json"},{"i":"jsonloadss","l":"json.loads(s)","p":["Decode a JSON string into a python object.","It is supported by the eval() function."]},{"i":"jsondumpsobj","l":"json.dumps(obj)","p":["Encode a python object into a JSON string.","It is supported by the compiler with JSON_MODE enabled."]}],[{"l":"linalg","p":["Provide mat3x3, vec2, vec3 and vec4 types.","https://github.com/blueloveTH/pocketpy/blob/main/include/typings/linalg.pyi"]}],[{"l":"math"},{"i":"mathpi","l":"math.pi","p":["3.141592653589793"]},{"i":"mathe","l":"math.e","p":["2.718281828459045"]},{"i":"mathinf","l":"math.inf","p":["The inf."]},{"i":"mathnan","l":"math.nan","p":["The nan."]},{"i":"mathceilx","l":"math.ceil(x)","p":["Return the ceiling of x as a float, the smallest integer value greater than or equal to x."]},{"i":"mathfabsx","l":"math.fabs(x)","p":["Return the absolute value of x."]},{"i":"mathfloorx","l":"math.floor(x)","p":["Return the floor of x as a float, the largest integer value less than or equal to x."]},{"i":"mathfsumiterable","l":"math.fsum(iterable)","p":["Return an accurate floating point sum of values in the iterable. Avoids loss of precision by tracking multiple intermediate partial sums:"]},{"i":"mathgcda-b","l":"math.gcd(a, b)","p":["Return the greatest common divisor of the integers a and b."]},{"i":"mathisfinitex","l":"math.isfinite(x)","p":["Return True if x is neither an infinity nor a NaN, and False otherwise."]},{"i":"mathisinfx","l":"math.isinf(x)","p":["Return True if x is a positive or negative infinity, and False otherwise."]},{"i":"mathisnanx","l":"math.isnan(x)","p":["Return True if x is a NaN (not a number), and False otherwise."]},{"i":"mathexpx","l":"math.exp(x)","p":["Return e raised to the power of x."]},{"i":"mathlogx","l":"math.log(x)","p":["Return the natural logarithm of x(to base e)."]},{"i":"mathlog2x","l":"math.log2(x)","p":["Return the base-2 logarithm of x. This is usually more accurate than log(x, 2)."]},{"i":"mathlog10x","l":"math.log10(x)","p":["Return the base-10 logarithm of x. This is usually more accurate than log(x, 10)."]},{"i":"mathpowx-y","l":"math.pow(x, y)","p":["Return x raised to the power y."]},{"i":"mathsqrtx","l":"math.sqrt(x)","p":["Return the square root of x."]},{"i":"mathacosx","l":"math.acos(x)","p":["Return the arc cosine of x, in radians."]},{"i":"mathasinx","l":"math.asin(x)","p":["Return the arc sine of x, in radians."]},{"i":"mathatanx","l":"math.atan(x)","p":["Return the arc tangent of x, in radians."]},{"i":"mathatan2y-x","l":"math.atan2(y, x)","p":["Return atan(y / x), in radians. The result is between -pi and pi. The vector in the plane from the origin to point (x, y) makes this angle with the positive X axis. The point of atan2() is that the signs of both inputs are known to it, so it can compute the correct quadrant for the angle. For example, atan(1) and atan2(1, 1) are both pi/4, but atan2(-1, -1) is -3*pi/4."]},{"i":"mathcosx","l":"math.cos(x)","p":["Return the cosine of x radians."]},{"i":"mathsinx","l":"math.sin(x)","p":["Return the sine of x radians."]},{"i":"mathtanx","l":"math.tan(x)","p":["Return the tangent of x radians."]},{"i":"mathdegreesx","l":"math.degrees(x)","p":["Convert angle x from radians to degrees."]},{"i":"mathradiansx","l":"math.radians(x)","p":["Convert angle x from degrees to radians."]},{"i":"mathmodfx","l":"math.modf(x)","p":["Return the fractional and integer parts of x. Both results carry the sign of x and are floats."]},{"i":"mathfactorialx","l":"math.factorial(x)","p":["Return x factorial as an integer."]}],[{"l":"os","p":["This module is optional. Set PK_ENABLE_OS to 1 to enable it."]},{"i":"osgetcwd","l":"os.getcwd()","p":["Returns the current working directory."]},{"i":"oschdirpath-str","l":"os.chdir(path: str)","p":["Changes the current working directory to the given path."]},{"i":"oslistdirpath-str","l":"os.listdir(path: str)","p":["Returns a list of files and directories in the given path."]},{"i":"osremovepath-str","l":"os.remove(path: str)","p":["Removes the file at the given path."]},{"i":"ossystemcommand-str---int","l":"os.system(command: str) - int","p":["Executes the given command in the system shell."]},{"i":"osmkdirpath-str","l":"os.mkdir(path: str)","p":["Creates a directory at the given path."]},{"i":"osrmdirpath-str","l":"os.rmdir(path: str)","p":["Removes the directory at the given path."]},{"i":"ospathjoinpaths-str","l":"os.path.join(*paths: str)","p":["Joins the given paths together."]},{"i":"ospathexistspath-str","l":"os.path.exists(path: str)","p":["Check if the given path exists."]},{"i":"ospathbasenamepath-str","l":"os.path.basename(path: str)","p":["Returns the basename of the given path."]}],[{"l":"pickle"},{"i":"pickledumpsobj---bytes","l":"pickle.dumps(obj) - bytes","p":["Return the pickled representation of an object as a bytes object."]},{"i":"pickleloadsb-bytes","l":"pickle.loads(b: bytes)","p":["Return the unpickled object from a bytes object."]},{"i":"what-can-be-pickled-and-unpickled","l":"What can be pickled and unpickled?","p":["The following types can be pickled:","None, True, and False;","integers, floating-point numbers;","strings, bytes;","tuples, lists, sets, and dictionaries containing only picklable objects;","functions (built-in and user-defined) accessible from the top level of a module (using def, not lambda);","classes accessible from the top level of a module;","instances of such classes","The following magic methods are available:","__getnewargs__","__getstate__","__setstate__","__reduce__"]}],[{"l":"random"},{"i":"randomseeda","l":"random.seed(a)","p":["Set the random seed."]},{"i":"randomrandom","l":"random.random()","p":["Return a random float number in the range [0.0, 1.0)."]},{"i":"randomrandinta-b","l":"random.randint(a, b)","p":["Return a random integer in the range [a, b]."]},{"i":"randomuniforma-b","l":"random.uniform(a, b)","p":["Return a random float number in the range [a, b)."]},{"i":"randomchoiceseq","l":"random.choice(seq)","p":["Return a random element from a sequence."]},{"i":"randomshuffleseq","l":"random.shuffle(seq)","p":["Shuffle a sequence inplace."]}],[{"l":"re"},{"i":"rematchpattern-string","l":"re.match(pattern, string)","p":["Return a match object if the string matches the pattern, and None otherwise. (force match at the beginning of the string)"]},{"i":"researchpattern-string","l":"re.search(pattern, string)","p":["Return a match object if the string matches the pattern, and None otherwise."]},{"i":"resplitpattern-string","l":"re.split(pattern, string)","p":["Split the string by the occurrences of the pattern."]},{"i":"resubpattern-repl-string","l":"re.sub(pattern, repl, string)","p":["Return a copy of the string with all occurrences of the pattern replaced by the replacement string."]}],[{"l":"sys"},{"i":"sysversion","l":"sys.version","p":["The version of pkpy."]},{"i":"sysplatform","l":"sys.platform","p":["May be one of:","win32","linux","darwin","android","ios","emscripten"]}],[{"l":"time"},{"i":"timetime","l":"time.time()","p":["Returns the current time in seconds since the epoch as a floating point number."]},{"i":"timesleepsecs","l":"time.sleep(secs)","p":["Suspend execution of the calling thread for the given number of seconds."]},{"i":"timelocaltime","l":"time.localtime()","p":["Returns the current struct time as a struct_time object."]}],[{"l":"timeit"},{"i":"timeittimeitf-number","l":"timeit.timeit(f, number)","p":["Returns the time taken to execute the given function f number times."]}],[{"l":"traceback"},{"i":"trackbackprint_exc---none","l":"trackback.print_exc() - None","p":["Print the last exception and its traceback."]},{"i":"trackbackformat_exc---str","l":"trackback.format_exc() - str","p":["Return the last exception and its traceback as a string."]}],[{"l":"typing","p":["Placeholder module for type hints."]}],[{"l":"Introduction"},{"l":"What C-API is for","p":["The C-APIs are designed for these purposes:","Your target platform does not support C++ 17. You compile pkpy into a static library and use its exported C-APIs.","You want to write a native module that can be imported via __import__ at runtime. By using C-APIs, the module is portable across different compilers without C++ ABI compatibility issues.","Our C-APIs take a lot of inspiration from the lua C-APIs. Methods return a bool indicating if the operation succeeded or not. Special thanks for @koltenpearson's contribution.","C-APIs are always stable and backward compatible."]},{"l":"Basic functions","p":["pkpy_vm* pkpy_new_vm(bool enable_os)","Wraps new VM(enable_os) in C++.","void pkpy_delete_vm(pkpy_vm*)","Wraps delete vm in C++.","bool pkpy_exec(pkpy_vm*, const char* source)","Wraps vm-exec. Execute a string of source code.","bool pkpy_exec_2(pkpy_vm*, const char* source, const char* filename, int mode, const char* module)","Wraps vm-exec_2. Execute a string of source code with more options."]}],[{"l":"Stack Manipulation"},{"l":"Basic manipulation","p":["bool pkpy_dup(pkpy_vm*, int)","Duplicate the value at the given index.","bool pkpy_pop(pkpy_vm*, int)","Pop n values from the stack.","bool pkpy_pop_top(pkpy_vm*)","Pop the top value from the stack.","bool pkpy_dup_top(pkpy_vm*)","Duplicate the top value on the stack.","bool pkpy_rot_two(pkpy_vm*)","Swap the top two values on the stack.","int pkpy_stack_size(pkpy_vm*)","Get the element count of the stack."]},{"i":"basic-push-check-and-convert","l":"Basic push, check and convert","p":["pkpy_push_xxx pushes a value onto the stack.","pkpy_is_xxx checks if the value at the given index is of the given type.","pkpy_to_xxx converts the value at the given index to the given type.","Stack index is 0-based instead of 1-based. And it can be negative, which means the index is counted from the top of the stack."]},{"l":"Special push","p":["pkpy_push_null(pkpy_vm*)","Push a PY_NULL onto the stack. It is used for pkpy_vectorcall.","pkpy_push_function(pkpy_vm*, const char* sig, pkpy_CFunction f)","Push a function onto the stack. sig is the function signature, e.g. add(a: int, b: int) - int. f is the function pointer.","pkpy_push_module(pkpy_vm*, const char* name)","Push a new module onto the stack. name is the module name. This is not import. It creates a new module object."]},{"l":"Variable access","p":["bool pkpy_eval(pkpy_vm*, const char* source)","bool pkpy_get_unbound_method(pkpy_vm*, pkpy_CName name)","bool pkpy_getattr(pkpy_vm*, pkpy_CName name)","bool pkpy_getglobal(pkpy_vm*, pkpy_CName name)","bool pkpy_py_repr(pkpy_vm*)","bool pkpy_setattr(pkpy_vm*, pkpy_CName name)","bool pkpy_setglobal(pkpy_vm*, pkpy_CName name)","bool pkpy_unpack_sequence(pkpy_vm*, int size)","Evaluate a string and push the result onto the stack.","Get the repr of the value at the top of the stack.","It is used for method call. Get an unbound method from the object at the top of the stack. name is the method name. Also push the object as self.","Push a global/builtin variable onto the stack. Return false if the variable is not found.","Push b.name onto the stack. Return false if the attribute is not found.","Set a global variable to the value at the top of the stack.","Set b.name to the value at the top of the stack. First push the value, then push b.","Unpack a sequence at the top of the stack. size is the element count of the sequence."]}],[{"l":"Call"},{"i":"bool-pkpy_vectorcallpkpy_vm-int-argc","l":"bool pkpy_vectorcall(pkpy_vm*, int argc)","p":["Wraps vm-vectorcall(argc). This function is used to call a function with a fixed number of arguments. The arguments are popped from the stack. The return value is pushed onto the stack.","First push the function to call.","Push self argument if it is a method call. Otherwise, call pkpy_push_null.","Push arguments from left to right.","Unlike lua, a python function always returns a value. If the function returns void, it will push None onto the stack. You can call pkpy_pop_top to discard the return value."]}],[{"l":"Specials","p":["void pkpy_free(void* p)","Wraps free(p) in C++.","pkpy_CString pkpy_string(const char*)","Construct a pkpy_CString from a null-terminated C string.","pkpy_CName pkpy_name(const char*)","Construct a pkpy_CName from a null-terminated C string. You should cache the result of this function if you are going to use it multiple times.","pkpy_CString pkpy_name_to_string(pkpy_CName)","Convert a pkpy_CName to a pkpy_CString."]}],[{"l":"Error Handling"},{"i":"bool-pkpy_clear_errorpkpy_vm-char-message","l":"bool pkpy_clear_error(pkpy_vm*, char** message)","p":["If a method returns false, call the pkpy_clear_error method to check the error and clear it","If pkpy_clear_error returns false, it means that no error was set, and it takes no action","If pkpy_clear_error returns true, it means there was an error and it was cleared. It will provide a string summary of the error in the message parameter if it is not NULL.","You are responsible for freeing message."]},{"i":"bool-pkpy_check_errorpkpy_vm","l":"bool pkpy_check_error(pkpy_vm*)","p":["Return true if the vm is currently in an error state."]},{"i":"bool-pkpy_errorpkpy_vm-const-char-name-pkpy_cstring-message","l":"bool pkpy_error(pkpy_vm*, const char* name, pkpy_CString message)","p":["Set the error state of the vm. It is almost equivalent to raise in python."]}],[{"l":"Welcome to PocketPython","p":["PocketPython is a C# plugin that allows you to do Python scripting in Unity. It provides a sandboxed Python environment, which adds dynamic capabilities to your game, which can be used for dynamic game logic, modding, hot fixing, and more.","The virtual machine is written in pure C#, which means you can fully control the internal state of the Python interpreter.","PocketPython is designed for game scripting, not for scientific computing. You cannot use it to run NumPy, OpenCV, or any other CPython extension modules."]},{"l":"Features"},{"i":"python-3x-syntax","l":"Python 3.x Syntax","p":["(1, 2, 'a')","[1, 2, 'a']","[i for i in range(5)]","{'a': 1, 'b': 2}","@cache","a, *b = [1, 2, 3]","a, b = 1, 2","a[1:2], a[:2], a[1:]","class A(B):","Context Block","Cpp","Decorator","def f(a:int, b:float=1)","def f(x,*args,y=1):","Dict","Dynamic Code","eval()/exec()","Example","Exception","F-String","f'value is {x}'","for/while/break/continue","Function","Generator","hasattr()/getattr()/setattr()","If Else","if..else..elif","Import","import/from..import","List","ListComp","Loop","Name","NO","PocketPython uses pocketpy as frontend to parse and compile Python source code. It supports most of the Python 3.x syntax.","raise/try..catch","Reflection","Slice","Star Unpacking","Subclass","The following table shows a feature comparison of PocketPython with respect to the original pocketpy. The features marked with YES are supported, and the features marked with NO are not supported.","Tuple","Type Annotation","Unity","Unpacking","with expr as id:","YES","yield i"]},{"l":"Sandboxed Python Environment","p":["PocketPython provides a sandboxed Python environment. All python code is executed in a C# virtual machine. The user cannot access the file system, network, or any other resources of the host machine."]},{"i":"seemless-interop-with-c","l":"Seemless Interop with C#","p":["...","bool","C# Type","dict","float","int","list","None","NoneType","object","PocketPython uses object in C# to represent dynamic typed Python objects. Most of the basic Python types correspond to a C# type, which means passing arguments between C# and Python is extremely easy and intuitive.","Python Type","str","System.Boolean","System.Collections.Generic.DictionaryPyDictKey, object","System.Collections.Generic.Listobject","System.Int32","System.Object","System.Object[]","System.Single","System.String","tuple"]},{"l":"Python Console in Editor","p":["PocketPython provides a Python console in Unity editor, which allows you to do quick debugging and testing."]}],[{"l":"Virtual machine","p":["The VM class provides a sandboxed Python environment and a set of APIs for interacting with it. Using the namespace PocketPython before any operations."]},{"l":"Construction","p":["VM()","Create a new Python virtual machine."]},{"l":"Code Execution","p":["CodeObject Compile(string source, string filename, CompileMode mode)","Compile Python source code into a CodeObject that can be executed later. The filename parameter is used for error reporting, you can set it to main.py if you don't need it. The mode parameter specifies the compile mode, see CompileMode for details.","object Exec(CodeObject co, PyModule mod = null)","Execute a CodeObject in the given module. The mod parameter specifies the module in which the code will be executed. If it is null, the code will be executed in the main module.","object Exec(string source, string filename, CompileMode mode = CompileMode.EXEC_MODE, PyModule mod = null)","Compile and execute Python source code in the given module. It is equivalent to Exec(Compile(source, filename, mode), mod).","object Eval(string source, PyModule mod = null)","Evaluate an expression in the given module.","object Call(object callable, object[] args, Dictionarystring, object kwargs)","Call a Python callable object with the given arguments and keyword arguments. It is equivalent to callable(*args, **kwargs) in Python.","object CallMethod(object obj, string name, params object[] args)","Call a method of a Python object with the given arguments. It is equivalent to obj.name(*args) in Python."]},{"l":"Attribute Access","p":["object GetAttr(object obj, string name, bool throwErr = true)","Get an attribute of a Python object. It is equivalent to obj.name in Python. If throwErr is true, it will throw an exception if the attribute does not exist. Otherwise, it will return null.","NoneType SetAttr(object obj, string name, object value)","Set an attribute of a Python object. It is equivalent to obj.name = value in Python.","bool HasAttr(object obj, string name)","Check if a Python object has the given attribute. It is equivalent to hasattr(obj, name) in Python."]},{"l":"Module Access","p":["Dictionarystring, PyModule modules","A dictionary that maps module names to PyModule objects. You can use it to access the modules that have been imported.","Dictionarystring, string lazyModules","A dictionary stores all unimported modules. You can add Python source into this dictionary. It will be initialized and moved to modules when it is first imported.","PyModule NewModule(string name)","Create a new module with the given name at runtime. The module will be added to modules automatically.","PyModule PyImport(string name)","Import a Python module. It is equivalent to import name in Python. It first checks if the module has been imported, if not, it will try to load the module from lazyModules."]},{"l":"Type Conversion","p":["bool IsInstance(object obj, PyTypeObject type)","bool PyBool(object obj)","bool PyEquals(object lhs, object rhs)","Check if a Python object is an instance of the given type. It is equivalent to isinstance(obj, type) in Python.","Check if t is T. Raise TypeError if the check fails.","Check if two Python objects are equal. It is equivalent to lhs == rhs in Python. This is different from == or object.ReferenceEquals in C#. You should always use this method to compare Python objects.","Convert a Python object to a boolean value. It is equivalent to bool(obj) in Python.","Convert a Python object to a C# object. It is equivalent to obj as T in C#. Raise TypeError if the conversion fails.","Convert a Python object to a string representation. It is equivalent to repr(obj) in Python.","Convert a Python object to a string. It is equivalent to str(obj) in Python.","Convert an Iterable Python object to a list. It is equivalent to list(obj) in Python.","Get an iterator of a Python object. It is equivalent to iter(obj) in Python.","Get the hash value of a Python object. It is equivalent to hash(obj) in Python.","Get the next element of a Python iterator. It is equivalent to next(obj) in Python.","int PyHash(object obj)","Listobject PyList(object obj)","object PyIter(object obj)","object PyNext(object obj)","string PyRepr(object obj)","string PyStr(object obj)","T PyCastT(object obj)","void CheckTypeT(object t)"]},{"l":"Callbacks","p":["System.Actionstring stdout = Debug.Log","A callback that will be called when the Python code invokes print function. By default, it will print the message to Unity console.","System.Actionstring stderr = null","A callback that will be called when the Python code emits an error message. By default, an Exception will be raised. You can set it to Debug.LogError for printing to the Unity Console."]},{"l":"Debug Flag","p":["bool debug = false","A flag that controls whether to print debug messages to Unity console. You can set it to true to enable debug messages, or false to disable them."]}],[{"l":"Bindings","p":["Bindings are methods and variables that are defined in C# and can be accessed from Python. We provide two types of bindings: static bindings and dynamic bindings."]},{"l":"Static Bindings","p":["Static bindings wrap a C# class or struct and expose its methods and variables to Python. This is the most common way to define bindings. Static bindings are initialized at compile time."]},{"l":"Manual Static Bindings","p":["Manual static bindings directly create a Python equivalent of def f(a, b, *args) in C#. To use it, you need to create a class that inherits from PyTypeObject. And implement some abstract methods to specify the name and type of the Python type. For example, to make UnityEngine.Vector2 available in Python, you can write a PyVector2Type class like the following.","Next, you need to define each method and variable to be exposed to Python, by using [PythonBinding] attribute.","We assume that you have necessary knowledge about Python's data model. Such as magic methods, __new__, __init__, __add__ and so on. Otherwise, you may have trouble understanding the following code.","Let's define a magic method __add__, it is used to implement the + operator in Python. With __add__, Vector2 object in Python can be added with another Vector2 object.","This is easy to understand. Let's see another example, __mul__, it is used to implement the * operator in Python. Vector2 object in C# can be multiplied with a float object in Python. The following code shows this usage.","As you can see, things are slightly different from __add__. Because the float operand can be on the left or right side of the * operator. In this case, you need to define __mul__ and __rmul__ at the same time.","Finally, let's implement the constructor of Vector2.__new__ magic method must be defined.","Here we use params object[] args to tell the bindings that the constructor can take any number of arguments. It is equivalent to def __new__(cls, *args) in Python. Note that Python does not support method overloading. So we manually check the number of arguments and their types to determine which constructor to call.","For fields, we can form a Python property by defining a getter and a setter. By using [PythonBinding(BindingType.Getter)] and [PythonBinding(BindingType.Setter)] attributes.","However, this has certain limitations for value types. Because Vector2 is a struct, it is passed by value. So our setter will not be able to modify the original Vector2 object.","Once you have done all the above, you must register the type to the VM. Here we set it into builtins module, so that it can be accessed from anywhere.","To summarize, manual static bindings provide detailed control for exposing a C# class to Python. You decide which methods and variables to expose, and how to expose them. This is our recommended way to define bindings. Also it is the most performant way."]},{"l":"Automatic Static Bindings","p":["Automatic static bindings use C# reflection to automatically generate bindings for a C# class. It is convenient for testing and prototyping, but it is slow and unsafe since the user can access any member of the class.","That's all you need to do. The RegisterAutoTypeT method will automatically generate bindings for Vector2."]},{"l":"Dynamic Bindings","p":["Dynamic bindings allow you to add a single C# lambda function to an object at runtime.","CSharpLambda BindFunc(PyObject obj, string name, int argc, NativeFuncC f)","It is similar to bind_func in C++ API."]}],[{"l":"Python console","p":["You can open the Python console in Unity by clicking the Window/Python Console menu item.","By default, the console creates a unmodified VM instance to execute your code. You may want to provide an enhanced VM instance for the console in Unity Editor. For example, adding some class bindings in UnityEngine namespace.","To do this, you need to create a class derived from VM and put it in Assets/Editor/ folder. By adding [EditorVM] attribute to the class, the console will use it instead of the default VM instance."]}],[{"l":"Examples","p":["See Assets/PocketPython/Examples after you import the plugin."]},{"l":"Primes Example"},{"l":"Vector2 Example"},{"l":"MyClass Example"}],[{"l":"Coding Style Guide"},{"l":"Naming rules","p":["For class names, always use PascalCase","For function and methods, use snake_case","For special python objects, use the same name as in python.","For global constants, use k prefix with PascalCase","For macros, use SNAKE_CASE"]},{"l":"Access control","p":["Please use python style access control.","We do not recommend to use C++ keywords such as private or public to achieve access control. Also do not write any trivial setter/getter.","Use a single _ as prefix to indicate a function or variable is for internal use.","_ prefix is just a warning to remind you to use such members carefully.","It does not forbid users to access internal members."]},{"l":"Use compact style","p":["Try to make the code compact if it does not affect readability."]},{"i":"for-stdshared_ptrt","l":"For std::shared_ptrT","p":["Use a _ suffix to indicate a type is a shared pointer."]}],[{"l":"Performance","p":["Currently, pkpy is as fast as cpython 3.8. Performance results for cpython 3.8 are applicable to for pkpy.","Here is a benchmark result of v1.0.0. Files are located in benchmarks/.","See actions/runs."]}],[{"l":"License","p":["pkpy is licensed under the MIT License."]}]]